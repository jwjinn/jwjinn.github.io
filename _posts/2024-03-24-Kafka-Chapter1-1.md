---
title: 카프카의 탄생 배경
description: 카프카의 탄생 배경, 발행/구독 시스템의 발전
author: joo
date: 24-03-31
categories: [Kafka, Chapter1]
tags: [kafka, Data, Engineering]
pin: true
math: true
mermaid: true

---

# 발행/구독 시스템 개념이 나온 이유

## 대학 시절에서는

제가 대학 시절과 취준생 시절에 만들었던 프로그램들을 생각을 해보았습니다.

하나의 파이선 프로그램에서 많은 데이터를 끌어 올 수 있도록 설계를 했을 겁니다.


```mermaid

flowchart LR
    Python <-->|Connects to| MariaDB
    Python <-->|Connects to| MongoDB
    Python <-->|Reads/Writes| CSV
    Python <-->|Connects to| OracleDB

```


MariaDB, MongoDB, CSV 파일, 그리고 또다른 DB인 ORACLE 까지도 하나의 파이선 프로그램이 다양하게 호출했습니다.

아직까지는 꽤 괜찮아 보입니다.
하나씩 사용한다고 가정한다면 파이선 모듈로 만들거나, 함수로 만들면 다루기 어려워 보이는 숫자는 아닙니다.

### 그렇지만, 현실은?

회사에 입사한 지 얼마 안된 저에게는 처음 접하는 DB인 Redis, ClickHouse, ElasticSearch까지 종류가 많이 늘어났습니다.

종류 뿐만 아니라, 각각의 솔루션들은 서로 실시간으로 통신을 하고 있습니다.
 
아 맞다. DB를 하나만 쓰는 경우는 보지 못했습니다. 
>이중화, 삼중화를 하게 되면 기본적으로 연결되는 수는 많아지게 됩니다.

### 많아 지게 되면 발생하는 문제점은?

우리가 데이터를 적재, 이동시키는 과정 중에서 문제가 발생을 할 때, 연결을 추적해야 하는 과정을 거쳐야 합니다.

직접 연결되는 것들이 많아지게 되면 연결 과정을 찾기가 어렵습니다.

뭐 마치... 내가 어지럽혀진 물건들 중 하나를 찾는 것보다

>"엄마!!" 하면서 외치면서 물건을 찾는 것을 엄마한테 위임(?)하는 것이 빠른 것처럼요.

### 아 이래서 발행/구독 메시지 전달 개념이 나왔구나.
예. 맞습니다.
그래서 발행/구독 메시지 전달 개념이 나왔습니다.

```mermaid

flowchart LR
    
    publisher -- push --> broker
    
    broker -- pull --- consummer

```
발행/구독 시스템에는 전송자(publisher)는 어떤 형태로든 메시지를 분류해서 보내고
수신자(consummer)는 **분류**된 메시지를 구독합니다.

그리고 그 과정에서 중계해주는 '브로커'가 있습니다.

#### 분류?
'분류'라는 표현을 사용했습니다. 뒤에서 자세히 설명을 하겠지만, 
'분류'는 관계형 데이터베이스에서의 '테이블'로 비유해서 이해하면 좋습니다.

우리는 테이블에 같은 주제(토픽)에 맞는 데이터를 입력합니다. 이렇게 분류가 되어 있기에 수신자 입장에서는 내 입맛에 맞는 데이터만 당길(pull)수 있습니다.

그래서, 꼭 **'분류'** 한다는 표현을 사용합니다.

# 1.1.1 초기의 발행/구독 시스템
초기의 발행/구독 시스템은 브로커를 거치지 않았습니다.

말그대로, '발행하는 자' 와 '구독하는 자' 와의 관계만 있었습니다.

서로가 서로에게 직접 연결하는 방식이였습니다.
```mermaid
flowchart LR

    프론트엔드_서버_1 --> 지표_서버
    프론트엔드_서버_2 --> 지표_서버

```
두 개의 프론트 엔드 서버에서 발생된 지표들을 한 개의 지표 서버로 보내는 구성입니다.

서비스 초기에는 나쁘지 않는 구성입니다.

그러나, 시간이 지나면서 당연하게도 서버가 늘어나게 됩니다.

```mermaid
flowchart LR

    s1 --> a1
    s1 --> a2
    s2 --> a3
    s2 --> a4
    s2 --> a1
    s1 --> a3


```
DB 서버가 추가가 되고, 그 DB의 이중화를 위한 서버가 추가가 되고 다른 기능들로 인해서

추가 기능을 위한 서버들이 또 추가가 되고 그 서버들을 구독해서 활용하는 애플리케이션들 또한 늘어나게 된다면....


>멀티탭에 멀티탭을 꼳은 상태에서 온갖 전자기기들을 꼳은 상태가 이 상태가 아닐까요?
>아!!! 게다가 선도 꼬여서 어디에서 시작하는 지를 알기가 어렵게 되었습니다.

그래서, 위에서 언급했던 것처럼 지표값 발행/구독 서버를 제공하는 것을 생각하게 되었습니다.

```mermaid
flowchart LR

    s1 --> 지푯값_발행_구독_서버
    s2 --> 지푯값_발행_구독_서버
    s3 --> 지푯값_발행_구독_서버
    s4 --> 지푯값_발행_구독_서버
    s5 --> 지푯값_발행_구독_서버

    지푯값_발행_구독_서버 --> A1
    지푯값_발행_구독_서버 --> A2
    지푯값_발행_구독_서버 --> A3
    지푯값_발행_구독_서버 --> A4
    지푯값_발행_구독_서버 --> A5


```
자 지금쯤 되면, 왜 지푯값 발행 구독 시스템이 탄생한 이유를 알게 되었을 겁니다!

# 1.1.2 개별 메시지 큐 시스템

지금까지는 지푯값 발행/구독 서버를 통해서 발행과 구독을 진행하는 것을 확인했습니다.

그러나, 현재 발행/구독 서버는 기본적으로 한가지의 역할만 가질 수 있습니다.

실시간 데이터를 수집한다면, 3개 타입의 데이터를 고려해야 합니다.

1. 지푯값 발행/구독
- >지푯값은 일반적으로 **성능 지표나 모니터링**을 위한 데이터입니다. 예를 들어, CPU 사용률, 메모리 사용량, 네트워크 트래픽 등이 해당됩니다.

2. 로그 메시지 발행/구독
- >로그 메시지는 시스템 또는 애플리케이션에서 발생하는 **이벤트나 상태 정보**를 기록하는 데 사용됩니다. 이는 주로 디버깅, 오류 추적, 성능 모니터링 등과 관련이 있습니다.

3. 사용자 추적 발행/구독
- >사용자 추적은 **사용자의 행동이나 활동을 추적하고 기록**하는 데 사용됩니다. 이는 주로 웹 애플리케이션, 모바일 앱, 온라인 서비스 등에서 사용자 경험을 개선하거나 비즈니스 인텔리전스를 얻기 위해 사용됩니다.

이렇게 되면, 3가지의 발행/구독 시스템을 구성해야 합니다.

데이터가 나오는 서버들은 동일하지만, 각 타입에 맞는 데이터가 나오도록 ETL을 진행을 합니다.

따라서, 데이터에 중복이 많고 다수의 데이터 큐 시스템을 구상해야 합니다.

> 엄마한테만 물건의 위치를 물으면 그만이지... 누나, 동생에게 까지 물건의 위치를 물을 수는 없잖아요...

일반화된 유형의 데이터를 발행하고 구독할 수 있는 중앙 집중화된 시스템의 필요성으로 **카프카가 탄생**했습니다.
